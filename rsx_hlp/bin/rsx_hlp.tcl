# 2004-06-18 (FP) transformation des fichiers ~/mnt/pdp/fab/hlp/*.HLP en ~/public_html/rsx11_hlp/*.html

package require tdom 0.7.7
package require fidev_xh 0.1                
package require fichUtils 0.2

# split échoue si la ligne contient des caractères nuls ^@
proc good_split {string char} {
    set i 0
    set ret [list]
    while 1 { 
	set j [string first $char $string $i]
	if {$j < 0} {
	    lappend ret [string range $string $i end]
	    return $ret
	}
	lappend ret [string range $string $i [expr {$j-1}]]
	set i [expr {$j+1}]
    }
}

proc list_from_file {filename} {
    set f [open $filename r]
    set var [good_split [read -nonewline $f] \n]
    close $f
    return $var
}



proc read_help_lines {help_list help} {
    global HELPS0 HLP
    set quoi $HLP($help)
    set N [llength $quoi]
    set subseen 0
    for {set i 0} {$i < $N} {incr i} {
	set line [lindex $quoi $i] 
	if {[regexp {^([1-9])(.*)$} $line tout level reste]} {
	    if {$level > [llength $help_list]} {
		return -code error "on saute au niveau $level à partir de \"$help_list\""
	    }
	    set sub [string trim $reste]
	    if {$reste == {}} {
		return -code error "sub vide ligne [expr {$i+1}] de ${help}" 
	    }
	    if {$subseen} {
		set HELPS0($help_list) $help_data
	    } else {
		set HELPS0($help_list) $help_data
		set subseen 1
	    }
	    set help_list [concat [lrange $help_list 0 [expr {$level-1}]] $sub]
	    if {[info exists HELPS0($help_list)]} {
		puts stderr "Il existe déjà HELPS0($help_list) [list read_help_lines $help_list $help]"
	    }
	    set help_data [list]
	} else {
	    lappend help_data $line
	}
    }
    if {$subseen} {
	set HELPS0($help_list) $help_data
    } else {
	set HELPS0($help_list) $help_data
    }
    return
}

proc cree_subs {} {
    global HELPS0 HELPS1 AROBASES AROTODO DIESES TYPE
    puts stderr "debut de cree_subs"
    foreach {k v} [array get HELPS0] {
	set c [lindex $v 0]
	set m [string index $c 0]
	switch $m {
	    {@} {
		set AROBASES($k) [string trimright [string range $c 1 end]]
		set AROTODO($k) {}
		foreach l [lrange $v 1 end] {
		    if {[string trim $l] != {}} {
			return -code error "Reste du blabla sur HELPS0($k)"
		    }
		}
		unset HELPS0($k)
		set TYPE($k) AROBASE
	    }
	    {#} {
		set DIESES($k) [string trimright [string range $c 1 end]]
		foreach l [lrange $v 1 end] {
		    if {[string trim $l] != {}} {
			return -code error "Reste du blabla sur HELPS0($k)"
		    }
		}
		unset HELPS0($k)
		set TYPE($k) DIESE
	    }
	    default {
		set HELPS1($k) $v
		unset HELPS0($k)		
		set TYPE($k) HELP
	    }
	}
    }
}


proc cree_name_from_list {l} {
    set n [file join $l __].html
    return $n
}


proc cree_html_from_hlp {quoi} {
    global HELPS1 DIESES AROBASES AROTODO TYPE
    puts stderr "debut de cree_html_from_hlp"
    set SCRIPT [file join [pwd] [info script]]
    
    set html    [xh::new]
                 xh::C  $html "== automatically generated by [::fidev::fichUtils::followLinks $SCRIPT] =="
    set laTete  [xh::E  $html     head]
    set leCorps [xh::E  $html     body {class body-sheet}]
                 xh::E  $laTete   meta {http-equiv "content-type" content "text/html; charset=ISO-8859-1"}
                 xh::E  $laTete   link {type text/css href /css/phydis_styles.css rel stylesheet}
                 xh::ET $laTete   title {} "RSX11M-PLUS $quoi"
                 xh::E  $leCorps  br
    set pre1   [xh::Es $leCorps {
	table {border 0 cellspacing 0 cellpadding 1 width 95% align center summary "sous-menus-entete"}
	tbody {}
	tr {}
	td {rowspan 1 colspan 1}
	pre {}
    }]
    set btsb    [xh::Es $leCorps {
	table {border 0 cellspacing 0 class table-sheet-border cellpadding 1 width 95% align center summary "table-sheet-border"}
	tbody {}
	tr {}
	td {rowspan 1 colspan 1 class "td-sheet"}
    }]
    set pre2    [xh::E  $btsb  pre]
                 xh::T  $pre2     [join $HELPS1($quoi) \n]

    set l [llength $quoi]

    set subs_helps [list]
    foreach q [array names HELPS1 "$quoi *"] {
	set s [lrange $q $l end]
	if {[llength $s] == 1} {
	    lappend subs_helps $s
	}
    }
    set subs_dieses [list]
    foreach q [array names DIESES "$quoi *"] {
	set s [lrange $q $l end]
	if {[llength $s] == 1} {
	    lappend subs_dieses $s
	}
    }
    set subs_arobases [list]
    foreach q [array names AROBASES "$quoi *"] {
	if {[info exists HELPS1($q)]} continue
	set s [lrange $q $l end]
	if {[llength $s] == 1} {
	    lappend subs_arobases $s
	}
    }

    xh::T $pre1 "        $quoi"

    set pre3   [xh::Es $leCorps {
	table {border 0 cellspacing 0 cellpadding 1 width 95% align center summary "sous-menus"}
	tbody {}
	tr {}
	td {rowspan 1 colspan 1}
	pre {}
    }]
    xh::T $pre3 \n
    set first 1
    foreach s [lsort [concat $subs_helps $subs_arobases]] {
	set fulls [concat $quoi $s]
	switch $TYPE($fulls) {
	    HELP {set link [cree_name_from_list $fulls]}
	    DIESE {
		set fulls [concat $quoi $DIESES($fulls)]
		if {[info exists HELPS1($fulls)]} {
		    set link [cree_name_from_list $fulls]l"
		} else {
		    set link {}
		}
	    }
	    default {
		set link {}
	    }
	}
	if {$first} {
	    xh::T $pre3 "        "
	    set sl [list]
	    foreach qq $quoi {
		lappend sl $qq
		xh::ET $pre3 a "href [cree_name_from_list $sl]" $qq
		xh::T $pre3 " "
	    }
	    set first 0
	    set remplace "         "
	    for {set il [string length $quoi]} {$il > 0} {incr il -1} {
		append remplace " "
	    }
	} else {
	    xh::T $pre3 $remplace
	}
	if {$link != {}} {
	    xh::ET $pre3 a "href $link" $s
	} else {
	    xh::T $pre3 $s
	}
        xh::T $pre3 "\n"
    }
    xh::T $pre3 "\n"
    foreach s [lsort $subs_dieses] {
	set fullo [concat $quoi $s]
	set fulls [concat $quoi $DIESES($fullo)]
	if {[info exists HELPS1($fulls)]} {
	    set link [cree_name_from_list $fulls]
	} else {
	    set link {}
	}
	if {$first} {
	    xh::T $pre3 "        "
	    set sl [list]
	    foreach qq $quoi {
		lappend sl $qq
		xh::ET $pre3 a "href [cree_name_from_list $sl]" $qq
		xh::T $pre3 " "
	    }
	    set first 0
	    set remplace "         "
	    for {set il [string length $quoi]} {$il > 0} {incr il -1} {
		append remplace " "
	    }
	} else {
	    xh::T $pre3 $remplace
	}
	if {$link != {}} {
	    xh::ET $pre3 a "href $link" "$s (Cf. $DIESES($fullo))"
	} else {
	    xh::T $pre3 $s
	}
        xh::T $pre3 "\n"
    }
    set leDoc   [xh::output $html]
    set filename ~/public_html/rsx11_hlp/[cree_name_from_list $quoi]
    set f [open $filename w]
    puts $f $leDoc
    close $f
    puts stderr "$filename est créé"
}


set DIR ~/mnt/pdp/FAB_HLP
set hs [glob $DIR/*.HLP]
set helpfiles [list]
foreach h $hs {
    lappend helpfiles [string range [file tail $h] 0 end-4]
}


foreach h $helpfiles {
    puts stderr "$h"
    set HLP($h) [list_from_file $DIR/${h}.HLP]
}
catch {unset HELPS0}
catch {unset HELPS1}
catch {unset DIESES}
catch {unset AROBASES}
catch {unset TYPE}

read_help_lines [list HELP] HELP
cree_subs

foreach k [array names AROTODO] {
    set h $AROBASES($k)
    if {![info exists ARODONE($k)]} {
	puts stderr $h
	if {[info exists HLP($h)]} {
	    read_help_lines $k $h
	} else {
	    puts stderr "  manque le fichier $h.HLP"
	}
	set ARODONE($k) {}
    }
    unset AROTODO($k)
}
cree_subs


foreach {k v} [array get DIESES] {
    set nk [concat [lrange $k 0 end-1] $v]
    if {![info exists AROBASES($nk)] && ![info exists HELPS1($nk)]} {
	puts stderr "il existe DIESES($k) mais ni AROBASES($nk) ni HELPS1($nk)"
    }
}


#read_help_lines [list HELP INDIRECT] ICP
#read_help_lines [list HELP SORT] SORT

foreach {k v} [array get HELPS1] {
    set err [catch {cree_html_from_hlp $k} blabla]
    if {$err} {
	puts stderr "ERREUR : $blabla"
    }
}

