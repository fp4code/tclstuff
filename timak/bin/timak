#!/bin/sh

# RCS: @(#) $Id: timak,v 1.11 2003/03/11 13:33:03 fab Exp $

# the next line restarts using tclsh \
exec tclsh "$0" "$@"


proc putsdebug {message} {
    if 0 {
        puts stderr $message
    }
}

set HELP(timak) {
# 8 avril 2002 (FP) portage Windows NT
# timak.1.5.tcl
# timak.1.4.tcl argument "type"
# 16 novembre 2000

set LIBS($libname) [concat $GLOBLIBS(complexmath) $GLOBLIBS(math)]
  ne marche pas
  reste = 0

set LIBS($libname) [concat ../../dblas1/src/libdblas1 $GLOBLIBS(complexmath) $GLOBLIBS(math)]
  marche

corrigé en introduisant "autonomous" dans ::algraph::depthList

# 3 mai 2000. On n'utilise plus "cd", qui est commun aux interpréteurs

Pour prévoir un travail parallèle, "timak" travaille en deux passes.

Dans une première passe, il collecte tous les "create ..." avec leurs relations
de dépendance directe.
Cette liste permet de construire un treillis.

Dans une seconde passe, "timak" exécute les "create ..." qui sont feuilles du treillis
puis toutes les branches dont les feuilles ont pu être créées correctement, etc.

#############
26 avril 2000
Exemples d'appel, nouvelle syntaxe
##################################

exec timak
exec timak -do default
exec timak -do lib
exec timak -do lib bin
exec timak -create lib libtcl_blas
exec timak -create libs {libtcl_blas libtcl_blos} program blassh
exec timak -create libs {libtcl_blas libtcl_blos} programs {blassh blassh2}
exec timak -do lib

exec timak -in blas
exec timak -in {blas blis blos}              ;# L'argument unique aurai permis d'autoriser un répertoire de nom "-do" INTERDIT
exec timak -in {blas blis blos} -do default  ;# INTERDIT, utiliser "foreach d {blas blis blos} {exec timak -in $d -do default}
exec timak -in {blas blis blos} -do lib bin  ;# INTERDIT (risques de confusion avec les noms comportant un blanc)
exec timak -in blas -create lib libtcl_blas programs {blassh blassh2} # interdit (on ne transmet que des "-do")

Équivalents dans les fichiers Timak.tcl: remplacer "exec timak" par "do -case xxx"

exec timak -> {-do default}
exec timak -do default -> {-do default}
exec timak -do lib -> {-do lib}
exec timak -create lib libtcl_blas

Dans un répertoire donné on peut
  - créer des choses (option -create ...)
  - mettre en oeuvre une indirection (option -do ...)
  - passer le bébé à un sous-répertoire (vérifier par "file split" que c'est bien un sous-répertoire)
Les procédures correspondantes sont timak::create, timak::do et timak::in.

#####################################################################################

on construit la liste de répertoires qui contiennent les fichiers "*.h" nécessaire
à la compilation

    set INCLUDES [list $TCLINCLUDEDIR ../../horreur/src]

on définit la liste des sources d'une bibliothèque

    set SOURCES(libtcl_blas) {tclBlas1Cmd.c tclBlas0Cmd.c tclBlasUtil.c tclBlasInit.c}

on définit la liste des bibliothèques que nécessite une bibliothèque.
Lorsqu'une bibliothèque est relative, on va dans le répertoire qui la
contient exécuter "timak" pour créer la bibliothèque. Ici:
"timak -do {create lib libtcl_blas}".

    set    LIBS(libtcl_blas) [list ../../../fortran/blas/src/libblas $TCLLIB libc]

idem pour créer un exécutable

    set SOURCES(blassh) mainTcl.c
    set    LIBS(blassh) [list ./libtcl_blas $TCLLIB]

crée la bibliothèque partagée "libtcl_blas" et le programme "blassh"

    do create lib libtcl_blas
    do create program blassh

des conditions sont possibles:

    do -case lib create lib libtcl_blas

#####################################################################################

QUE FAIT TIMAK ? (obsolète ?)

- lancé à partir d'un répertoire, le programme "timak"
commence par vérifier que le fichier "Timak.tcl" existe.

S'il n'existe pas, c'est une erreur grave.

On suppose donc que le fichier "Timak.tcl" existe.
"timak" examine l'existence dans le répertoire parent
du fichier "Timak.tcl".
On remonte comme cela jusqu'au dernier répertoire ancêtre
contenant un fichier "Timak.tcl".

L'interpréteur se place ensuite dans un namespace vierge,
(ou bien dans un nouvel interpréteur)
importe la commande "::timak::do"
et exécute sur chaque fichier "Timak.tcl"
la commande Tcl "source", en partant de l'ancêtre et
en finissant par le répertoire d'où la commande "timak"
a été lancée. Toutes les commandes "::timak::do"
sont ignorées lors de la lecture des fichiers parents

Dans le cas d'une commande "do subdir", l'interpréteur
passe dans ce répertoire et lance la commande "timak".

Dans une version plus élaborée, on commence par
construire une liste de choses à créer.

}

namespace eval timak {
    variable PWD
}


#####################################################
# UTILITAIRES unambiguousPwd, timakFiles, reverseList

proc horreur {err} {

    if {!$err} {
        return
    }
    
    global errorInfo tcl_interactive
    puts stderr $errorInfo
    
    if {$tcl_interactive} {
        puts stderr "exit $err"
    } else {
        exit $err
    }
}

proc ::timak::nativeDir {list} {
    return [file nativename [eval file join $list]]
}


set HELP(::timak::unambiguousPwd) {
    retourne un identificateur non ambigu, au moyen d'une variable globale PWD
    ex : /export/global/Home/fab et /home/fab sont ambigus sur la machine "u5fico" du L2M.
    On predra garde que [pwd] est lié à la variable env(PWD), et que
    comme lui, il est le même pour tous les interpréteurs
}

proc ::timak::unambiguousPwd {} {
    variable PWD
    set pwd [pwd]
    file lstat $pwd a
    set ui "$a(dev),$a(ino)" ;# unambiguous id DANGER, architecture dependant
    if {[info exists PWD($ui)]} {
        return $PWD($ui)
    } else {
        set PWD($ui) $pwd
        return $pwd
    }
}

namespace eval ::timak {
    variable PWD [pwd]
    variable INCLUDES [list]
    variable CFLAGS [list]
    variable LIBS
    ###### pour diagnostiquer les dépendances circulaires

    variable MARKIN
    variable MARKOUT

    variable STOP
    set STOP(compile) 1
    set STOP(createObj) 1
    variable DEBUG
    set DEBUG(depend) 1
    set DEBUG(call) 0  
    set DEBUG(general) 0  
}

############################
set HELP(::timak::readTimak) {
  un répertoire racine $root étant donné sous forme de liste
  un sous-répertoire $dir étant donné sous forme de liste
  la procédure retourne le contenu du fichier Timak.tcl
  révisions {
      {27 avril 2000} {}
      {3 mai 2000} {}
  }

  Utilisation {::timak::readTimaks}
}
proc ::timak::readTimak {fulldir} {
    if {[catch {
        set fichier [eval file join $fulldir Timak.tcl]
        set f [open $fichier r]
        set ret [read -nonewline $f]
        close $f
    } message]} {
        return -code error "file \"$fichier\": $message"
    }
    return $ret
}

##########################
set HELP(::timak::getRoot) {
    4 mai 2000 (FP)

    Un répertoire étant donné sous forme de liste {/ home fab A fidev Tcl} ou {D:/ users fab}
    on remonte les parents jusqu'à trouver le dernier répertoire contenant un fichier Timak.tcl
    On retourne l'index dans la liste "$directory" qui correspond à la racine 

    Utilisation {::timak::readTimaks}
}

proc ::timak::getRoot {directory} {
    set nativedir [eval file join $directory]
    
    if {![file isdirectory $nativedir]} {
        return -code error "\"$nativedir\" is not a directory"
    }
    if {[file pathtype $nativedir] == "relative"} {
        return -code error "\"$nativedir\" is not absolute pathtype (it's [file pathtype $nativedir])"
    }
 
    if {![file exists [file join $nativedir Timak.tcl]]} {
        return -code error "No \"Timak.tcl\" file"
    }

    set i [expr {[llength $directory] - 1}]
    set itest [expr {$i - 1}]

    while {[file exists [eval file join [lrange $directory 0 $itest] Timak.tcl]] && $i != 0} {
        set i $itest
        incr itest -1
    }
    return $i
}

#############################
set HELP(::timak::readTimaks) {
    Cette procédure sert à récupérer le contenu d'une lignée de fichiers Timak.tcl

    Ces fichiers sont 
    - un répertoire racine $root étant donné sous forme de liste
    - un répertoire $directory étant donné sous forme de liste
    - On charge (si cela n'a pas été fait) le tableau de nom $TIMAKSName
      du contenu des fichiers Timak.tcl. Le nom du répertoire (sous forme de liste) forme l'index.

    retour: liste des répertoires

    revisions {
        {27 avril 2000} {}
        {3 mai 2000} {suppression des "cd"}
    }

    Utilisation {Préliminaire à FirstPass}
}
proc ::timak::readTimaks {root TIMAKSCONTENTSName reldir} {
    upvar $TIMAKSCONTENTSName TIMAKSCONTENTS

    #set iroot [::timak::getRoot $directory]
    #set root [lrange $directory 0 $iroot]
    #if {$root != $rootControl} {
    #    return -code error "Splitted directory \"$directory\" has \"$root\" as root, I want \"$rootControl\"."
    #}

    
    if {![info exists TIMAKSCONTENTS()]} {
        # Tcl admet un indice "vide" pour les tableaux associatifs
        set TIMAKSCONTENTS() [::timak::readTimak $root]
    }
    set TimakDirs [list {}]
    set dir [list]
    foreach d $reldir {
        lappend dir $d
        if {![info exists TIMAKSCONTENTS($dir)]} {
	    putsdebug [list $root $dir]
            set TIMAKSCONTENTS($dir) [::timak::readTimak [concat $root $dir]]
        }     
        lappend TimakDirs $dir
    }
    return $TimakDirs
}

##################################
set HELP(::timak::giveAncestors) {
    ::timak::giveAncestors {q w e} -> {} q {q w} {q w e}
}

###################################
proc ::timak::giveAncestors {dir} {
###################################

    set ret [list]
    set imax [llength $dir]
    for {set i -1} {$i < $imax} {incr i} {
        lappend ret [lrange $dir 0 $i]
    }
    return $ret
}


################################


####################################
set HELP(::timak::interpretTimaks) {

    modifie CASEDO par l'intermédiaire des commandes "do ..." contenues dans 
    les fichiers Timaks

    Les valeurs sont triées et jamais dupliquées

}

###################################################################
proc ::timak::interpretTimaks {TIMAKSCONTENTSName ROOT TimakDirs} {
###################################################################

    upvar $TIMAKSCONTENTSName TIMAKSCONTENTS

    # Il faudrait masquer le nom des variables

    foreach dir [lrange $TimakDirs 0 end-1] {
        set IGNORE_DO 1
        if {[catch {eval $TIMAKSCONTENTS($dir)} message]} {
            return -code error "error sourcing in $dir: $message"
        }
    }
    set dir [lindex $TimakDirs end]
    set IGNORE_DO 0

    if {[catch {eval $TIMAKSCONTENTS($dir)} message]} {
        global errorInfo
        puts stderr $errorInfo
        return -code error "error sourcing in $dir: $message"
    }

    set ret1 [list]
    foreach key [lsort [array names DO_LIST]] {
        catch {unset X}
        foreach do $DO_LIST($key) {
            set X($do) {}
        }
        lappend ret1 $key [lsort [array names X]]
    }

    set ret2 [list]
    foreach key [lsort [array names CREATE_LIST]] {
        catch {unset X}
        foreach do $CREATE_LIST($key) {
            set X($do) {}
        }
        lappend ret2 $key [lsort [array names X]]
    }

    set ret3 [list]
    foreach x [lsort [array names LIBS]] {
	putsdebug "lib x = $x"
        set libs [list]
        foreach lib [lsort $LIBS($x)] {
            if {$lib == {}} {
                # return -code error "void lib"
		puts stderr "Warning, void lib"
		continue
            }
            set lib [file split $lib]
            if  {[file pathtype [lindex $lib 0]] != "relative" || [llength $lib] == 1} {
                continue
                # not relative lib
            }
            set libFromRoot $dir
            while {[llength $lib] > 0} {
                set d [lindex $lib 0]
                set lib [lrange $lib 1 end]
                switch $d {
                    "." {}
                    ".." {set libFromRoot [lrange $libFromRoot 0 end-1]}
                    default {lappend libFromRoot $d}
                }
            }
            lappend libs $libFromRoot
        }
        if {$libs != {}} {
            lappend ret3 $x $libs
        }
    }

    return [list $ret1 $ret2 $ret3]
}

#######################
set HELP(::timak::do) {
C'est la commande qui est appelée par les lignes "do ..." des fichiers "Timak.tcl"

}

#########################
proc ::timak::do {args} {
#########################

    upvar IGNORE_DO IGNORE_DO
    upvar DO_LIST DO_LIST
    upvar CREATE_LIST CREATE_LIST

    if {$IGNORE_DO} {
	return
    }
    
    set SYNTAX "wrong # args: should be \"::timak::do ?-case aAcase? ...\""
    
    if {[llength $args] < 1} {
	return -code error "command \"do $args\": $SYNTAX"
    }
    
    # do -case toto -create ...
    
    set reste $args

    if {[lindex $args 0] == "-case"} {
        set case [lindex $reste 1]
        set reste [lrange $reste 2 end]
    } else {
        set case default
        set reste [lrange $reste 0 end]
    }
    
    if {[lindex $reste 0] == "-in"} {
        set in [lindex $reste 1]
        set reste [lrange $reste 2 end]
    } else {
        set in .
        set reste [lrange $reste 0 end]
    }
    if {[string index [lindex $reste 0] 0] == "-"} {
        switch -exact [string range [lindex $reste 0] 1 end] {
            "do" {set dos [lrange $reste 1 end]}
            "create" {
                set create [lrange $reste 1 end]
                if {[llength $create] != 2} {
                    return -code error "-create type name"
                }
            }
            default {
                return -code error "bad do: $args"
            }
        }
    } else {
        set dos $reste
    }

    if {[info exists dos]} {
        if {$dos == {}} {
            if {$in == "." || $case == "default"} {
                set dos [list default]
            } else {
                return -code error "do ambigu: $args"
            }
        }
        foreach do $dos {
            lappend DO_LIST($case) [list $in $do]
        }
    }
    if {[info exists create]} {
        lappend CREATE_LIST($case) $create
    }
}

################################
set HELP(timak::interpretArgs) {
    

}

###############################################
proc timak::interpretArgs {caseName in  args} {
###############################################

}




############################
set HELP(timak::firstPass) {
    {
        {26 avril 2000} {(FP)}
        {27 avril 2000} {(FP) Refonte complète}
    }

    retourne une liste de dépendances
    {
        {
            répertoire {program blassh} répertoire {lib libtcl_blas} répertoire {lib libblas}
        }
        {
            répertoire {program blassh2} répertoire {lib libtcl_blas}
        }
    }

    Chaque élément de la liste correspond à un objet à construire à partir d'un répertoire donné
    Chaque élément de la liste est une liste, dont les 2 premiers éléments représentent
           ce qui est à construire, et dont les paires d'éléments suivants sont les éléments nécessaires
   $$$ Non terminé

}

proc timak::firstPass {TIMAKSCONTENTSName CREATEName ROOT dir doList createList} {
    upvar $TIMAKSCONTENTSName TIMAKSCONTENTS
    upvar $CREATEName CREATE

    putsdebug "$dir"

    set TimakDirs [::timak::readTimaks $ROOT TIMAKSCONTENTS $dir]
    set ici [lindex $TimakDirs end]

    # création d'un interpréteur indépendant
    set interp [interp create]

    $interp alias ::timak::interpretTimaks ::timak::interpretTimaks
   
    # Interprétation des fichiers pour en retirer la "dolist" 

    set err [catch {$interp eval [list ::timak::interpretTimaks TIMAKSCONTENTS $ROOT $TimakDirs]} message]
    if {$err} {
        global errorInfo
        puts stderr "ERREUR, message = $message"
        puts stderr "      , errorInfo = $errorInfo"
        return -code error "IRRÉMÉDIABLE"
    }

    array set CASEDO [lindex $message 0]
    array set CASECREATE [lindex $message 1]
    array set LIBDEPENDS [lindex $message 2]

    # Les tableaux sont créés même vides

    # construction du type à partir du nom

    foreach case [array names CASECREATE] {
        foreach create $CASECREATE($case) {
            foreach {type nom} $create {break}
            if {[info exists TYPE($nom)] && $TYPE($nom) != $type} {
                return -code error "Le nom \"$nom\" a les deux types \"$TYPE($nom)\" et \"$type\""
            }
            set TYPE($nom) $type
        }
    }

    foreach x [array names LIBDEPENDS] {
        set libs $LIBDEPENDS($x)
        unset LIBDEPENDS($x)
        if {![info exists TYPE($x)]} {
            puts stderr "LIBS($x) inutile dans le Timak de [timak::nativeDir [concat $ROOT $dir]]"
            continue
        }
        set type $TYPE($x)
        switch -exact $type {
            "program" {
                # Il faudrait une variable globale pour faire un choix statique/dynamique
                set deptype lib
            }
            "lib" {
                set deptype lib
            }
            default {
                return -code error "type de \"$x\" inconnu : \"$type\""
            }
        }
        set newlibs [list]
        foreach lib $libs {
            lappend newlibs [list [lrange $lib 0 end-1] [concat $deptype [lindex $lib end]]]
        }
        putsdebug [list set LIBDEPENDS([list $dir [list $type $x]]) $newlibs]
        set LIBDEPENDS([list $dir [list $type $x]]) $newlibs
    }

    foreach do $doList {set DOLIST($do) {}}
    if {$createList != {}} {
        if {[info exists DOLIST(create)]} {
            return -code error "\"create\" is a reserved word; use \"do -create\", no \"do -do create\""
        }
        set  DOLIST(create) {}
        set CASECREATE(create) $createList
    }

    while {[array names DOLIST] != {}} {
        set do [lindex [array names DOLIST] 0]
        if {![info exists CASEDO($do)] && ![info exists CASECREATE($do)]} {
            if {$do != "nothing"} {
                return -code error "ERROR: I don't know how to do \"$do\" in [timak::nativeDir $dir]"
            } else {
                set VU($do) {}
                unset DOLIST($do)
                continue
            }
        }
        set VU($do) {}
        unset DOLIST($do)
        if {[info exists CASEDO($do)]} {
            foreach ww $CASEDO($do) {
                foreach {where what} $ww {break}
                if {$where == "."} {
                    if {![info exists VU($what)]} {
                        set DOLIST($what) {}
                    }
                } else {
                    lappend IN($where) $what
                }
            }
        }
        if {[info exists CASECREATE($do)]} {
            foreach x $CASECREATE($do) {
                set create [list $dir $x]
                if {[info exists LIBDEPENDS($create)]} {
                    putsdebug [list set CREATE($create) $LIBDEPENDS($create)]
                    set CREATE($create) $LIBDEPENDS($create)
                } else {
                    set CREATE($create) {}
                }
            }
        }
    }
    putsdebug [list dir = $dir]
    putsdebug [list IN = [lsort [array names IN]]]
    foreach subdir [lsort [array names IN]] {
        timak::firstPass TIMAKSCONTENTS CREATE $ROOT [concat $dir [list $subdir]] $IN($subdir) {}
    }
    return
}

set HELP(timak::finishFirstPass) {
    On se retrouve avec des CREATE(A) {B C D}
    Sans CREATE(B)
}

proc timak::finishFirstPass {TIMAKSCONTENTSName ROOT CREATEName} {
    upvar $TIMAKSCONTENTSName TIMAKSCONTENTS
    upvar $CREATEName CREATE
    
    # parray CREATE

    foreach c [array names CREATE] {
        foreach todo $CREATE($c) {
            if {![info exists CREATE($todo)]} {
                if {[info exists TODO($todo)]} {
                    incr TODO($todo)
                } else {
                    set TODO($todo) 1
                    putsdebug [list todo = $todo -> [lindex $todo 0]]
                    lappend DOLISTINDIR([lindex $todo 0]) [lindex $todo 1]
                }
            }
        }
    }
    set dirs [array names DOLISTINDIR]
    putsdebug " reste = [llength $dirs]"
    # if {[llength $dirs] != 0} {parray DOLISTINDIR}
    putsdebug [list dirs = $dirs]
    foreach dir [lsort $dirs] {
        timak::firstPass TIMAKSCONTENTS CREATE $ROOT $dir {} $DOLISTINDIR($dir)
    }
    return [llength $dirs]
}

#******************************************************************#
#                  GRAPHES ALGÉBRIQUES                             #
#******************************************************************#

namespace eval algraph {}

set HELP(::dag::treillis) {
    ou "acyclic digraph" ou "directed acyclic graph" ou "DAG"
    "outdegree" = nombre de flèches qui sortent

    Chaque "arc"

}

set HELP(::algraph::arclist) {

    en entrée, $arcsOfNode(A) contient la liste des noeuds B
    pour lesquelles il y a un arc de A vers B.

    en sortie, on a une liste paire représentant les arcs.

    si $arcsOfNode(A) == {B C D}, $arcsOfNode(B) == {C E}, le retour sera
    {A B  A C  A D  B C  B E}

    how:
       -alreadyClean: supposées propres
       -verif: on vérifie qu'il n'y a pas d'arcs doubles
       -cleanIt: les arcs doubles sont supprimés

}


proc ::algraph::arcList {how &arcsOfNode} {
    upvar ${&arcsOfNode} arcsOfNode

    if {![info exists arcsOfNode]} {
        return {}
    }
    set ret [list]
    switch -- $how {
        "-alreadyClean" {
            foreach a [array names arcsOfNode] {
                foreach b $arcsOfNode(a) {
                    lappend ret $a $b
                }
            }
        }
        "-verif" {
            foreach a [array names arcsOfNode] {
                if {[info exists B]} {
                    unset B
                }
                foreach b $arcsOfNode($a) {
                    if {[info exists B($b)]} {
                        return -code error "node \"$a\" has two arcs to \"$b\""
                    }
                    lappend ret $a $b
                    set B($b) {}
                }
            }
        }
        "-cleanIt" {
            foreach a [array names arcsOfNode] {
                if {[info exists B]} {
                    unset B
                }
                foreach b $arcsOfNode($a) {
                    if {![info exists B($b)]} {
                        lappend ret $a $b
			set B($b) {}
                    }
                }
            }
        }
        default {
            return -code error "bad argum(s) \"$args\", should be \"-alreadyClean\", \"-verif\" or \"-cleanIt\""
        }
    }
    return $ret
}

set HELP(::algraph::fillArcListArray) {
    Le tableau array est supposé vide en entrée

    La liste $list est une liste paire a1 b1 a2 b2 a3 b3 ...
    représentant des arcs (ai bi)

    En sortie, array est indexé par les noeuds A d'où part au moins un arc.
    $array(A) est la liste des noeuds où arrive un arc partant de A.
    
    Retourne une liste contenant tous les noeuds qui n'ont besoin de personne,
    où arrive au moins un arc, mais d'où n'en part aucun.
    Un noeud ne figure jamais deux fois dans la liste.
}

proc ::algraph::fillArcListArray {&array list} {
    upvar ${&array} array 

    array set LEAF {}
    # Le tableau LEAF existe et est vierge
    foreach {a b} $list {
        lappend array($a) $b
        set LEAF($b) {}
    }
    # Les index du tableau array sont les noeuds A d'où part au moins un arc
    # $array(A) est la liste des noeuds où arrive un arc partant de A
    # Les index du tableau LEAF sont les noeuds où arrive au moins un arc 
    set ret [list]
    # $ret est une liste vierge
    foreach b [array names LEAF] {
        if {![info exists array($b)]} {
            lappend ret $b
        }
    }
    return $ret
    # On retourne une liste contenant tous les noeuds qui n'ont besoin de personne,
    # où arrive au moins un arc, mais d'où n'en part aucun.
    # Un noeud ne figure jamais deux fois dans la liste.
}

set HELP(::algraph::fillReverseArcListArray) {

    Le tableau array est supposé vide en entrée

    La liste $list est une liste paire a1 b1 a2 b2 a3 b3 ...
    représentant des arcs (ai bi)

    En sortie, array est indexé par les noeuds A d'où part au moins un arc.
    $array(A) est la liste des noeuds où arrive un arc partant de A.
    
    # On retourne une liste contenant tous les noeuds qui ne sont nécessaires à personne,
    # d'où part au moins un arc, mais où n'en arrive aucun.
    # Un noeud ne figure jamais deux fois dans la liste.
}

proc ::algraph::fillReverseArcListArray {&array list} {
    upvar ${&array} array
    
    array set LEAF {}
    # LEAF est un tableau existe et est vierge
    foreach {a b} $list {
        lappend array($b) $a
        set LEAF($a) {}
    }
    # Les index du tableau array sont les noeuds B où arrive au moins un arc
    # $array(B) est la liste des noeuds d'où part un arc arrivant en B
    # Les index du tableau LEAF sont les noeuds d'où part au moins un arc 
    set ret [list]
    # $ret est une liste vierge   
    foreach a [array names LEAF] {
        if {![info exists array($a)]} {
            lappend ret $a
        }
    }
    return $ret
    # On retourne une liste contenant tous les noeuds qui ne sont nécessaires à personne,
    # d'où part au moins un arc, mais où n'en arrive aucun.
    # Un noeud ne figure jamais deux fois dans la liste.
}

set HELP(::algraph::depthList) {
    On a des noeuds.
    Un noeud n'est jamais isolé.
    Deux noeuds A B sont éventuellement réunis par un arc unique orienté,
    appelé "a besoin de"
    Si A a besoin de B, B figure dans la liste $arcsOfNode(A)

    Le graphe est supposé acyclique
    
    Si un noeud n'a besoin de personne, on dira qu'il
    a une profondeur 0.
    Si un noeud a besoin d'au moins un noeud,
    mais n'a besoin que des noeuds de profondeur 0, on dira
    qu'il a la profondeur 1.
    Si un noeud a besoin d'au moins un noeud de profondeur 1,
    et seulement de noeuds de profondeur 1 ou 0, on dira qu'il a
    la profondeur 2.
    Si un noeud a besoin d'au moins un noeud de profondeur N,
    et seulement de noeuds de profondeur <= N, on dirq qu'il
    a la profondeur N+1.
}

proc ::algraph::depthList {&arcsOfNode} {
    upvar ${&arcsOfNode} arcsOfNode

    set autonomous [list]
    foreach b [array names arcsOfNode] {
        if {$arcsOfNode($b) == {}} {
            lappend autonomous $b
        }
    }
    putsdebug "autonomous = $autonomous"

    set arclist [::algraph::arcList -cleanIt arcsOfNode]
    # $arcList est une liste paire a1 b1 a2 b2 a3 b3 ... où (ai bi) est un arc.
    # Il est garanti qu'aucun arc ne figure en double

    array set AL {}
    # Le tableau AL est vierge et existant
    set leafs [::algraph::fillArcListArray AL $arclist]
    # Le tableau AL existe
    # Le tableau AL a pour index les noeuds A d'où part au moins un arc
    # $AL(A) est la liste des noeuds où arrive un arc partant de A
    # $leafs est la liste des noeuds qui n'ont besoin de personne
    putsdebug "AL:"
    # parray AL
    putsdebug "leafs = $leafs"

    array set RAL {}
    # Le tableau RAL est vierge et existant
    ::algraph::fillReverseArcListArray RAL $arclist
    # Le tableau RAL existe
    # Le tableau RAL a pour index les noeuds B où arrive au moins un arc
    # $RAL(B) est la liste des noeuds d'où partent un arc arrivant en B

    foreach a [array names AL] {
        set OUTDEG($a) [llength $AL($a)]
    }
    # Le tableau OUTDEG n'existe pas nécessairement
    # Le tableau OUTDEG a pour index les noeuds A d'où part au moins un arc
    # $OUTDEG($a) est le nombre d'arcs partant de A

    array set HERE {}
    if {$leafs != {}} {
        foreach b $leafs {
            set HERE($b) {}
        }
    } else {
        if {[llength $autonomous] != 1} {
            puts stderr "WARNING : \[llength \$autonomous\] == [llength $autonomous]"
        }
    }
    foreach b $autonomous {
        set HERE($b) {}
    }
    # Le tableau HERE existe
    # Les index du tableau HERE sont les noeuds d´où ne part aucun arc.
    putsdebug HERE:
    # parray HERE

    set prof 0
    set nextProf 1
    array set PROF {}
    # PROF est un tableau vierge
    while {[info exists HERE]} {
	# Les index du tableau HERE sont les noeuds de profondeur $prof
        set nodes [array names HERE]
	# $nodes est la liste des noeuds de profondeur $prof
        unset HERE
	# HERE n'existe plus
	# Il sera éventuellement rempli
	# Sinon, la prochaine boucle ne sera pas affectuée
        foreach b $nodes {
            set PROF($b) $prof
	    # PROF contiendra la profondeur des noeuds
            if {[info exists RAL($b)]} {
		# Il arrive au moint un arc sur $b 
                foreach a $RAL($b) {
		    # balayage de tous les noeuds d'où part un arc en direction de $b
                    incr OUTDEG($a) -1
                    if {$OUTDEG($a) == 0} {
			# On a balayé tous les arcs partant de $a, donc PROF($a) == $prof + 1
                        if {[info exists PROF($a)]} {
			    #  PROF($a) <= $prof : contradiction
                            return -code error "Cyclic Graph on node \"$a\""
                        }
                        set PROF($a) $nextProf
                        set HERE($a) {}
                    }
                }
            }
	}
	# HERE contient tous les noeuds de profondeur $prof + 1
        incr prof
        incr nextProf
    }

    array set IPROF {}
    foreach a [array names PROF] {
        lappend IPROF($PROF($a)) $a
    }
        
    set ret [list]
    foreach i [lsort -integer [array names IPROF]] {
        lappend ret $IPROF($i)
    }
    putsdebug [list ret = $ret]
    return $ret
}

#******************************************************************#

###########################
set HELP(::timak::createIt) {
    Chaque répertoire a son interpréteur Tcl attitré, défini par le tableau
    de nom $INTERPSName, indexé par $repertoire
    S'il n'existe pas, l'interpréteur est créé et initialisé au moyen
    de la lignée de fichiers Timak.tcl
    
    L'argument $what contient deux éléments, nature et nom
    La procédure ::timak::create est appelée avec ces deux arguments

    Il peut paraitre inefficace de lancer plusieurs interpréteurs,
    mais n'oublions pas qu'à terme, ils seront lancés sur plusieurs machines
    en parallèle.
}
proc ::timak::createIt {ROOT TIMAKSCONTENTSName INTERPSName repertoire what} {

    upvar $TIMAKSCONTENTSName TIMAKSCONTENTS
    upvar $INTERPSName INTERPS

    if {[info exists INTERPS($repertoire)]} {
        putsdebug "  exists"
        set interp $INTERPS($repertoire)
    } else {
        putsdebug "\nnew interp is created in $repertoire"
        # création de l'interpréteur indépendant
        set interp [interp create]
        $interp alias ::timak::unambiguousPwd ::timak::unambiguousPwd
        $interp alias ::timak::getScript ::timak::getScript
        $interp alias ::timak::do ::timak::do
        
        #
        global CREATESCRIPTS
        $interp eval $CREATESCRIPTS
        #

        foreach dir [::timak::giveAncestors $repertoire] {
            set IGNORE_DO 1
            if {[catch {$interp eval [list namespace eval timak [::timak::getScript TIMAKSCONTENTS $dir]]} message]} {
                global errorInfo
                return -code error "error sourcing in $dir: $errorInfo"
            }
        }
        # enregistrement de l'interpréteur
        set INTERPS($repertoire) $interp
    }

    # le "pwd", comme tous les "env" est partagé par tous les interpréteurs
    cd [timak::nativeDir [concat $ROOT $repertoire]]
    if {[catch {$interp eval ::timak::create [lindex $what 0] [lindex $what 1]} message]} {
        global errorInfo
        return -code error "error creating \"$what\" in \"$repertoire\": $errorInfo"
    }
}

################################################
proc ::timak::getScript {TIMAKSCONTENTSName dir} {
    upvar $TIMAKSCONTENTSName TIMAKSCONTENTS
    if {![info exists TIMAKSCONTENTS($dir)]} {
        if {![info exists TIMAKSCONTENTS]} {
            set read "nothing"
        } else {
            set read [lsort [array names TIMAKSCONTENTS]]
        }
        return -code error "\nThe script in \"$dir\" is not in readlist\nReadlist is: \{$read\}"
    }
    return $TIMAKSCONTENTS($dir)
}

set HELP(global) {
    
    Au plan global, il existe une procédure permet de savoir où mettre le résultat
    d'une opération en fonction de la source

    Un bibliothèque sera créée virtuellement dans le répertoire du fichier Timak.tcl
    qui contient la liste des sources.
}


set f [info script]
while {[file type $f] == "link"} {
    set ff [file readlink $f]
    if {[file pathtype $ff] == "relative"} {
        set ff [file join [file dirname $f] $ff]
    }
    if {$f == $ff} {
        return -code error "loopback link: \"$f\""
    }
    set f $ff
    putsdebug $ff
}


set CREATESCRIPTS {
# Un ensemble de commandes qui doivent être interprétées
# au préalable par chaque interpréteur



# création de fichiers objet
# $fsrc = fichier source
# $fdst = fichier objet à créer
# moreRecentVar = nom d'une variable à mettre à jour
# variable INCLUDES = liste d'arguments

proc putsdebug {message} {
    if 0 {
        puts stderr $message
    }
}

proc ::timak::filejoin {args} {
    set clean [list]
    foreach e $args {
	if {$e == "."} {
	    continue
	} elseif {$e == ".."} {
	    if {$clean == {} || [lindex $clean end] == ".."} {
		lappend clean $e
	    } else {
		set clean [lrange $clean 0 end-1]
	    }
	} else {
	    lappend clean $e
	}
    }
    return [eval file join $clean]
}

proc timak::createSharedObjFromFortran {fsrc fdst moreRecentVar} {
    set command [timak::SharedObjFromFortran $fdst $fsrc]
    upvar $moreRecentVar moreRecent
    return [timak::createSomething $fsrc $fdst moreRecent $command]
}

proc timak::createObjFromFortran {fsrc fdst moreRecentVar} {
    set command [timak::ObjFromFortran $fdst $fsrc]
    upvar $moreRecentVar moreRecent
    return [timak::createSomething $fsrc $fdst moreRecent $command]
}

proc timak::createSharedObjFromC {fsrc fdst moreRecentVar} {
    variable DEBUG
    if {$DEBUG(call)} {
	puts stderr "timak::createSharedObjFromC $fsrc $fdst $moreRecentVar"
    }
    set src [file dirname $fsrc]
    set command [timak::SharedObjFromC $fdst $fsrc]
    upvar $moreRecentVar moreRecent
    return [timak::createSomething $fsrc $fdst moreRecent $command]
}

proc timak::createObjFromC {fsrc fdst moreRecentVar} {
    set src [file dirname $fsrc]
    set command [timak::ObjFromC $fdst $fsrc]
    upvar $moreRecentVar moreRecent
    return [timak::createSomething $fsrc $fdst moreRecent $command]
}

proc timak::createSharedObjFromC++ {fsrc fdst moreRecentVar} {
    variable DEBUG
    if {$DEBUG(call)} {
	puts stderr "timak::createSharedObjFromC++ $fsrc $fdst $moreRecentVar"
    }
    set src [file dirname $fsrc]
    set command [timak::SharedObjFromC++ $fdst $fsrc]
    upvar $moreRecentVar moreRecent
    return [timak::createSomething $fsrc $fdst moreRecent $command]
}

proc timak::createObjFromC++ {fsrc fdst moreRecentVar} {
    set src [file dirname $fsrc]
    set command [timak::ObjFromC++ $fdst $fsrc]
    upvar $moreRecentVar moreRecent
    return [timak::createSomething $fsrc $fdst moreRecent $command]
}

set HELP(timak::createSomething) {
    28 avril 2000
    La compilation des objets pour les bibliothèques les programmes
    est actuellement faite "sur place".
    On peut imaginer étendre le système de dépendances
    pour permettre une compilation en parallèle sur plusieurs machines
}

proc timak::createSomething {fsrc fdst moreRecentVar command} {
    variable DEBUG
    global errorCode errorInfo

    upvar $moreRecentVar moreRecent
    if {$DEBUG(call)} {
	puts stderr [list timak::createSomething $fsrc $fdst &$moreRecent $command]
    }

    if {![file exists $fsrc]} {
	return -code error "inexistent source file: \"$fsrc\"" 
    }
    if {$DEBUG(call)} {
        puts stderr "[file exists $fdst] = file exists $fdst"
        if {[file exists $fdst]} {
            puts stderr "[file mtime $fsrc] = file mtime $fsrc"
            puts stderr "[file mtime $fdst] = file mtime $fdst"
            puts stderr "$moreRecent = moreRecent"
        }
    }

    if {[file exists $fdst] && [file mtime $fsrc] <= [file mtime $fdst]} {
	if {$moreRecent < [file mtime $fdst]} {
	    set moreRecent [file mtime $fdst]
	    if {$DEBUG(depend)} {
		puts stderr "createSomething [file mtime $fdst] [pwd]/$fdst"
	    }
	}
	return 0
    } 
    puts stderr [list command = $command]
    set err [catch {eval exec $command} blabla]
    if {$err == 0} {
        puts stderr "OK 0"
	if {$moreRecent < [file mtime $fdst]} {
	    set moreRecent [file mtime $fdst]
	}
        return 0
    }
    if [info exists errorCode] {
        set savedErrorCode $errorCode ;# est-ce utile ?
    } else {
        set savedErrorCode "PAS DE errorCode"
    }

    if {$savedErrorCode == "NONE"} {
        puts stderr "OK NONE"
        foreach l [split $blabla \n] {
            puts stderr "    $l"
        }
	if {$moreRecent < [file mtime $fdst]} {
	    set moreRecent [file mtime $fdst]
	}
	return 0
    }
    if {[file exists $fdst]} {
	file delete $fdst
    }
    if {[lindex $savedErrorCode 0] == "CHILDSTATUS"} {
	puts stderr $blabla
	return -code error "*** compilation error(s)"
    } else {
	puts stderr $blabla
	return -code error "*** errorCode -> $savedErrorCode"
    }
}

set HELP(::timak::create) {
    création d'un programme ou d'une bibliothèque
}

proc ::timak::create {progOrLib name} {
    # tableaux des sources et des bibliothèques
    variable SOURCES
    variable LIBS
    variable STOP
    variable DEBUG
    variable EXEC
    
    global errorCode
    
    set static [expr {[info exists EXEC(staticLib)] && $EXEC(staticLib)}]

    set fortranFiles 0
    set CFiles 0
    set C++Files 0
    set errors 0
    set pwd [pwd]
    if {$DEBUG(call)} {
        puts stderr $pwd 
    }
    set objs [list]
    set moreRecent 0
    set objDest [timak::destFromSource obj $pwd]
    if {$DEBUG(call)} {
	puts stderr [list timak::create $progOrLib $name]
    }    

    switch $progOrLib {
	"program" {
	    set fromFortran timak::createObjFromFortran
	    set fromC timak::createObjFromC
	    set fromC++ timak::createObjFromC++
	    set finalName $name
	    set finalDest [timak::destFromSource bin $pwd]
            set PLSuffix Program
	}
	"lib" {
            if {$static} {
                set fromFortran timak::createObjFromFortran
                set fromC timak::createObjFromC
                set fromC++ timak::createObjFromC++
                set finalName [staticLibName $name]
                set finalDest [timak::destFromSource lib $pwd]                
            } else {
                set fromFortran timak::createSharedObjFromFortran
                set fromC timak::createSharedObjFromC
                set fromC++ timak::createSharedObjFromC++
                set finalName [sharedLibName $name]
                set finalDest [timak::destFromSource lib $pwd]
                set PLSuffix SharedLib
            }
        }
	default {
	    return -code error "*** timak::createProgramOrLib: \"$progOrLib\" should be \"program\" or \"lib\""
	}
    }
    
    cd $objDest
    set realDest [pwd]
    
    foreach f [set SOURCES($name)] {
	set type [timak::getTypeOfFile $f]
	set obj [file rootname [file tail $f]].o
	lappend objs $obj
	switch $type {
	    "fortran" {
		set err [catch {$fromFortran $pwd/$f $obj moreRecent} message]
		if {!$err} {
		    incr fortranFiles
		} else {
                    puts stderr "ERREUR MAKING fortran \"$obj\": $message" 
                }
	    }
	    "C" {
		set err [catch {$fromC $pwd/$f $obj moreRecent} message]
		if {!$err} {
		    incr CFiles
		} else {
                    puts stderr "ERREUR MAKING C \"$obj\": $message"
                }
	    }
	    "C++" {
		set err [catch {${fromC++} $pwd/$f $obj moreRecent} message]
		if {!$err} {
		    incr C++Files
		} else {
                    puts stderr "ERREUR MAKING C++ \"$obj\": $message"
                }
	    }
	    default {
		set message  "*** timak::createProgramOrLib unknown type \"$type\""
                set err 1
	    }
	}
	if {$err} {
	    if {$STOP(createObj)} {
                global errorInfo
		return -code error "\nerrorInfo=\n$errorInfo\n$message=\n$message"
	    } 
	    puts stderr "ERROR: $message"
	    incr errors
	}
    }

    # on retourne au plus aux sources, mais on se rappelle le lieu de compilation
    cd $pwd
    
    if {$errors != 0} {
	return -code "*** incomplete compilation"
    }

    if {$static && $progOrLib == "lib"} {
        set linker linkerArchive
        set command [linkerArchive $finalName $objs]
    } else {    
        if {$fortranFiles != 0} {
            set linker linkerFortran$PLSuffix
	} elseif {${C++Files} != 0} {
	    set linker linkerC++$PLSuffix
        } else {
            set linker linkerC$PLSuffix
        }

        if {[info exists LIBS($name)]} {
            set libs [timak::libs $LIBS($name) $finalDest]
        } else {
            set libs {}
        }
    
        set command [$linker [list $finalName] $objs $libs]
    }

    putsdebug "*** [list cd $realDest] ***"
    cd $realDest

    if {[file exists $finalName]} {
	set fnmt [file mtime $finalName]
	if {$DEBUG(depend)} {
	    puts stderr "create          $fnmt [file join $realDest $finalName]"
            puts stderr "moreRecent =    $moreRecent"
	}	    
	if {$moreRecent <= $fnmt} {
	    cd $pwd
	    return
	}
    } else {
	if {$DEBUG(depend)} {
	    puts stderr "inexistent [file join $realDest $finalName]"
	}
    }
    
    puts stderr $command
    set err [catch {eval exec $command} blabla]
    puts stderr $blabla
    if [info exists errorCode] {
        set savedErrorCode $errorCode ;# est-ce utile ?
    } else {
        set savedErrorCode "PAS DE errorCode"
    }

    if {!$err && $static && $progOrLib == "lib"} {
        set command [list ranlib $finalName]
        puts stderr $command
        set err [catch {eval exec $command} blabla2]
        puts stderr $blabla2
        lappend savedErrorCode $errorCode ;# est-ce utile ?        
    }

    cd $pwd

    if {$err == 0 || $savedErrorCode == "NONE"} {
	puts stderr "OK, $finalName is made in $realDest"
	return
    }
    
    if {[file exists [file join $realDest $finalName]]} {
	file delete [file join $realDest $finalName]
    }
    if {[lindex $savedErrorCode 0] == "CHILDSTATUS"} {
	puts stderr $blabla
	return -code error "*** link error(s)"
    } else {
	puts stderr $blabla
	return -code error "*** errorCode -> \"$savedErrorCode\""
    }
}

proc timak::includes {src} {
    variable INCLUDES

    putsdebug [list INCLUDES = $INCLUDES]

    set elems [list]
    set srcdir [file dirname $src]
    foreach elem $INCLUDES {
	lappend elems [timak::include $srcdir $elem]
    }
    return $elems
}

proc timak::include {src elem} {
    variable DEBUG
    if {$DEBUG(call)} {
	puts stderr "timak::include $src $elem"
    }
    set path [file split $elem]
    set pathtype [file pathtype [lindex $path 0]]
    switch $pathtype {
	"absolute" {
	    set path [eval file join $path]
	}
	"volumerelative" {
	    set path [eval file join $path]
	}
	"relative" {
	    if {$path == "."} {
		set path $src
	    } else {
		set path [eval ::timak::filejoin [file split $src] $path]
	    }
	}
	default {
	    return -code error "*** ERROR: Unknown path type \"$pathtype\" for \"[lindex $path 0]\""
	}
    }
    if {$DEBUG(call)} {
	puts stderr "-> -I$path"
    }
    
    return "-I$path"
}

proc timak::libs {liblist dest} {
# puts stderr "timak::libs $liblist $dest"
    set libs [list]
    putsdebug "liblist = \"$liblist\""
    foreach lib $liblist {
	set lib [timak::lib $lib $dest]
	putsdebug "+ $lib"
	eval lappend libs $lib
    }
    return $libs
}

proc timak::lib {lib dest} {
    variable EXEC
    global errorCode
    set libpath [file split $lib]
    if {[llength $libpath] > 1} {
	set libname [lindex $libpath end]
	set libpath [lrange $libpath 0 end-1]
    } else {
	set libname $libpath
	set libpath {}
    }
    if {![string match lib* $libname]} {
	return -code error "*** ERROR: \"$libname\" has not \"lib...\" form"
    }
    set liblib -l[string range $libname 3 end]
    if {$libpath == {}} {
	return $liblib
    } else {
	set pathtype [file pathtype [lindex $libpath 0]]
	switch $pathtype {
	    "absolute" {
		set path [eval file join $libpath]
	    }
	    "volumerelative" {
		set path [eval file join $libpath]
	    }
	    "relative" {
		if {$libpath == "."} {
		    set path $dest
		} else {
		    set path [eval ::timak::filejoin [file split $dest] $libpath]
		}
	    }
	    default {
		return -code error "*** ERROR: Unknown path type \"$pathtype\""
	    }
	}
# puts stderr "return : path = $path, liblib = $liblib"
	return [concat [timak::libPaths $path] [list $liblib]]
    }
}


proc timak::getTypeOfFile {f} {
    set extension [file extension $f]
    switch $extension {
	".f" {return fortran}
	".f90" {return fortran}
	".f95" {return fortran}
	".c" {return C}
	".cpp" {return C++}
	".c++" {return C++}
	".cc"  {return C++}
	".cxx" {return C++}
	default {return -code error "*** timak::getTypeOfFile unknown extension: \"$extension\""}
    }
}

namespace eval ::timak {
    variable PWD [pwd]
    variable INCLUDES [list]
    variable CFLAGS [list]
    variable LIBS
    ###### pour diagnostiquer les dépendances circulaires

    variable MARKIN
    variable MARKOUT

    variable STOP
    set STOP(compile) 1
    set STOP(createObj) 1
    variable DEBUG
    set DEBUG(depend) 1
    set DEBUG(call) 0  
    set DEBUG(general) 0  
}


}

######################
#                    #
# DÉBUT DU PROGRAMME #
#                    #
######################

#puts stderr ##############################
#puts stderr [concat $argv0 $argv]
#puts stderr ##############################
#puts stderr {}

# lecture des procédures dans l'interpréteur principal
# lecture des fichiers, sans interprétation


set rien {
    set pwd [file split [pwd]]
    set ROOT [lrange $pwd 0 [::timak::getRoot $pwd]]
    set TimakDirs [::timak::readTimaks $ROOT TIMAKSCONTENTS [file split [pwd]]]
    
    putsdebug "TimakDirs -> $TimakDirs"
    putsdebug "ROOT -> $ROOT"
    
    puts stderr {}
    puts stderr  ################################
    puts stderr "essai direct de la seconde passe"
    puts stderr  ################################
    puts stderr {}
    
    cd /home/fab/A/fidev/Tcl/blas/src
    set TimakDirs [::timak::readTimaks $ROOT TIMAKSCONTENTS [file split [pwd]]]
    puts stderr [list TIMAKSCONTENTS: [array names TIMAKSCONTENTS]]
    
    ::timak::createIt $ROOT TIMAKSCONTENTS INTERPS {Tcl blas src} {lib libtcl_blas}
    ::timak::createIt $ROOT TIMAKSCONTENTS INTERPS {Tcl blas src} {program blassh}
    
    puts stderr {}
    puts stderr  ######################################
    puts stderr "autre essai direct de la seconde passe"
    puts stderr  ######################################
    puts stderr {}
    
    cd /home/fab/A/fidev/Tcl/pvm/src
    set TimakDirs [::timak::readTimaks $ROOT TIMAKSCONTENTS [file split [pwd]]]
    
    ::timak::createIt $ROOT TIMAKSCONTENTS INTERPS {Tcl pvm src} {lib libtclpvm}
    
    cd /home/fab/A/fidev/Tcl/scilab/src
    set TimakDirs [::timak::readTimaks $ROOT TIMAKSCONTENTS [file split [pwd]]]
    
    ::timak::createIt $ROOT TIMAKSCONTENTS INTERPS {Tcl scilab src} {lib libtclscilab}
    
    puts stderr {}
    puts stderr  ##############
    puts stderr "fin de l'essai"
    puts stderr  ##############
    puts stderr {}
}

set A(a) {}
set A(b) {}
set A(c) {}
set A(d) {}
set A(e) {}
set A(f) {a b}
set A(g) {a b e}
set A(h) {a f d e}

#cd /home/fab/A/fidev/Tcl/vector
set pwd [file split [pwd]]
set i [::timak::getRoot $pwd]
set ROOT [lrange $pwd 0 $i]
incr i
set dir [lrange $pwd $i end]

putsdebug {}
putsdebug [list ROOT = $ROOT]

if {$argv != {} && [string index [lindex $argv 0] 0] != "-"} {
    set env(TIMAKTYPE) [lindex $argv 0]
    set argv [lrange $argv 1 end]
} elseif {![info exists env(TIMAKTYPE)]} {
    set env(TIMAKTYPE) optim
}

if {$argv == {}} {
    set dolist default
    set createlist {}
} else {
    if {[string index [lindex $argv 0] 0] != "-"} {
        puts stderr "usage : timak -do ..., or timak -create ..."
        exit 1
    }
    if {[lindex $argv 0] == "-do"} {
        set dolist [lrange $argv 1 end]
        set createlist {}
    } elseif {[lindex $argv 0] == "-create"} {
        set dolist {}
        set createlist [list]
        foreach {type nom} [lrange $argv 1 end] {
            lappend createlist [list $type $nom]
        }
    } else {
        puts stderr "usage : timak -do ..., or timak -create ..."
        exit 1
    }
}

putsdebug [list dolist = $dolist createlist = $createlist]

horreur [catch {timak::firstPass TIMAKSCONTENTS CREATE $ROOT $dir $dolist $createlist} message]

while {[set reste [timak::finishFirstPass TIMAKSCONTENTS $ROOT CREATE]] != 0} {
    putsdebug "reste->$reste"
}

#if {[catch {parray CREATE} message]} {
#    puts $message
#}

set ordres [::algraph::depthList CREATE]

putsdebug [list ordres = $ordres]

proc ::timak::reverseList {list} {
    set ret [list]
    set i [llength $list]
    for {incr i -1} {$i >= 0} {incr i -1} {
	lappend ret [lindex $list $i]
    }
    return $ret
}

set i 0
foreach o $ordres {
    foreach x [lsort $o] {
        # putsdebug "$i $x"
        ::timak::createIt $ROOT TIMAKSCONTENTS INTERPS [lindex $x 0] [lindex $x 1]
    }
    incr i
}

exit 0





